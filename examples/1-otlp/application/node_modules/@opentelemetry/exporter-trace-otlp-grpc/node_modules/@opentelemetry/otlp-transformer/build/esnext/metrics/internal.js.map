{"version":3,"file":"internal.js","sourceRoot":"","sources":["../../../src/metrics/internal.ts"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;GAcG;AACH,OAAO,EAAE,SAAS,EAAE,MAAM,4BAA4B,CAAC;AACvD,OAAO,EAAE,mBAAmB,EAAE,MAAM,qBAAqB,CAAC;AAC1D,OAAO,EACL,sBAAsB,EAEtB,aAAa,EAGb,cAAc,EAGf,MAAM,iCAAiC,CAAC;AACzC,OAAO,EAAE,YAAY,EAAE,MAAM,oBAAoB,CAAC;AAUlD,MAAM,UAAU,iBAAiB,CAAC,eAAgC;IAChE,OAAO;QACL,QAAQ,EAAE;YACR,UAAU,EAAE,YAAY,CAAC,eAAe,CAAC,QAAQ,CAAC,UAAU,CAAC;YAC7D,sBAAsB,EAAE,CAAC;SAC1B;QACD,SAAS,EAAE,SAAS;QACpB,YAAY,EAAE,cAAc,CAAC,eAAe,CAAC,YAAY,CAAC;KAC3D,CAAC;AACJ,CAAC;AAED,MAAM,UAAU,cAAc,CAAC,YAA4B;IACzD,OAAO,KAAK,CAAC,IAAI,CAAC,YAAY,CAAC,GAAG,CAAC,OAAO,CAAC,EAAE;QAC3C,MAAM,YAAY,GAAkB;YAClC,KAAK,EAAE;gBACL,IAAI,EAAE,OAAO,CAAC,KAAK,CAAC,IAAI;gBACxB,OAAO,EAAE,OAAO,CAAC,KAAK,CAAC,OAAO;aAC/B;YACD,OAAO,EAAE,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,UAAU,CAAC,EAAE,CAAC,QAAQ,CAAC,UAAU,CAAC,CAAC;YAChE,SAAS,EAAE,OAAO,CAAC,KAAK,CAAC,SAAS;SACnC,CAAC;QACF,OAAO,YAAY,CAAC;IACtB,CAAC,CAAC,CAAC,CAAC;AACN,CAAC;AAED,MAAM,UAAU,QAAQ,CAAC,UAAsB;IAC7C,MAAM,GAAG,GAAY;QACnB,IAAI,EAAE,UAAU,CAAC,UAAU,CAAC,IAAI;QAChC,WAAW,EAAE,UAAU,CAAC,UAAU,CAAC,WAAW;QAC9C,IAAI,EAAE,UAAU,CAAC,UAAU,CAAC,IAAI;KACjC,CAAC;IAEF,MAAM,sBAAsB,GAAG,wBAAwB,CAAC,UAAU,CAAC,sBAAsB,CAAC,CAAC;IAE3F,IAAI,UAAU,CAAC,aAAa,KAAK,aAAa,CAAC,QAAQ,EAAE;QACvD,MAAM,UAAU,GAAG,oBAAoB,CAAC,UAAU,CAAC,CAAC;QACpD,MAAM,WAAW,GAAG,UAAU,CAAC,UAAU,CAAC,IAAI,KAAK,cAAc,CAAC,OAAO;YACvE,UAAU,CAAC,UAAU,CAAC,IAAI,KAAK,cAAc,CAAC,kBAAkB,CAAC;QACnE,IAAI,KAAK,CAAC,UAAU,CAAC,EAAE;YACrB,GAAG,CAAC,GAAG,GAAG;gBACR,sBAAsB;gBACtB,WAAW;gBACX,UAAU;aACX,CAAC;SAEH;aAAM;YACL,yBAAyB;YACzB,GAAG,CAAC,KAAK,GAAG;gBACV,UAAU;aACX,CAAC;SACH;KACF;SAAM,IAAI,WAAW,CAAC,UAAU,CAAC,EAAE;QAClC,GAAG,CAAC,SAAS,GAAG;YACd,sBAAsB;YACtB,UAAU,EAAE,qBAAqB,CAAC,UAAU,CAAC;SAC9C,CAAC;KACH;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AAED,SAAS,mBAAmB,CAAC,SAAmD,EAAE,SAAoB;IACpG,MAAM,GAAG,GAAqB;QAC5B,UAAU,EAAE,YAAY,CAAC,SAAS,CAAC,UAAU,CAAC;QAC9C,iBAAiB,EAAE,mBAAmB,CACpC,SAAS,CAAC,SAAS,CACpB;QACD,YAAY,EAAE,mBAAmB,CAC/B,SAAS,CAAC,OAAO,CAClB;KACF,CAAC;IAEF,IAAI,SAAS,KAAK,SAAS,CAAC,GAAG,EAAE;QAC/B,GAAG,CAAC,KAAK,GAAG,SAAS,CAAC,KAAe,CAAC;KACvC;SAAM,IAAI,SAAS,KAAK,SAAS,CAAC,MAAM,EAAE;QACzC,GAAG,CAAC,QAAQ,GAAG,SAAS,CAAC,KAAe,CAAC;KAC1C;IAED,OAAO,GAAG,CAAC;AACb,CAAC;AAED,SAAS,oBAAoB,CAC3B,UAAsB;IAEtB,OAAO,UAAU,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;QAC3C,OAAO,mBAAmB,CAAC,SAAS,EAAE,UAAU,CAAC,UAAU,CAAC,SAAS,CAAC,CAAC;IACzE,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAS,qBAAqB,CAC5B,UAAsB;IAEtB,OAAO,UAAU,CAAC,UAAU,CAAC,GAAG,CAAC,SAAS,CAAC,EAAE;QAC3C,MAAM,SAAS,GAAG,SAAS,CAAC,KAAkB,CAAC;QAC/C,OAAO;YACL,UAAU,EAAE,YAAY,CAAC,SAAS,CAAC,UAAU,CAAC;YAC9C,YAAY,EAAE,SAAS,CAAC,OAAO,CAAC,MAAM;YACtC,cAAc,EAAE,SAAS,CAAC,OAAO,CAAC,UAAU;YAC5C,KAAK,EAAE,SAAS,CAAC,KAAK;YACtB,GAAG,EAAE,SAAS,CAAC,GAAG;YAClB,GAAG,EAAE,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,SAAS;YACpD,GAAG,EAAE,SAAS,CAAC,SAAS,CAAC,CAAC,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,SAAS;YACpD,iBAAiB,EAAE,mBAAmB,CAAC,SAAS,CAAC,SAAS,CAAC;YAC3D,YAAY,EAAE,mBAAmB,CAC/B,SAAS,CAAC,OAAO,CAClB;SACF,CAAC;IACJ,CAAC,CAAC,CAAC;AACL,CAAC;AAED,SAAS,KAAK,CAAC,MAAkB;IAC/B,OAAO,CAAC,MAAM,CAAC,UAAU,CAAC,IAAI,KAAK,cAAc,CAAC,OAAO;QACvD,MAAM,CAAC,UAAU,CAAC,IAAI,KAAK,cAAc,CAAC,eAAe;QACzD,MAAM,CAAC,UAAU,CAAC,IAAI,KAAK,cAAc,CAAC,kBAAkB;QAC5D,MAAM,CAAC,UAAU,CAAC,IAAI,KAAK,cAAc,CAAC,0BAA0B,CAAC,CAAC;AAC1E,CAAC;AAED,SAAS,WAAW,CAAC,MAAkB;IACrC,OAAO,MAAM,CAAC,aAAa,KAAK,aAAa,CAAC,SAAS,CAAC;AAC1D,CAAC;AAED,SAAS,wBAAwB,CAC/B,WAAmC;IAEnC,IAAI,WAAW,KAAK,sBAAsB,CAAC,KAAK,EAAE;QAChD,6CAA6D;KAC9D;IAED,IAAI,WAAW,KAAK,sBAAsB,CAAC,UAAU,EAAE;QACrD,kDAAkE;KACnE;IAED,mDAAmE;AACrE,CAAC","sourcesContent":["/*\n * Copyright The OpenTelemetry Authors\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nimport { ValueType } from '@opentelemetry/api-metrics';\nimport { hrTimeToNanoseconds } from '@opentelemetry/core';\nimport {\n  AggregationTemporality,\n  DataPoint,\n  DataPointType,\n  Histogram,\n  ScopeMetrics,\n  InstrumentType,\n  MetricData,\n  ResourceMetrics\n} from '@opentelemetry/sdk-metrics-base';\nimport { toAttributes } from '../common/internal';\nimport {\n  EAggregationTemporality,\n  IHistogramDataPoint,\n  IMetric,\n  INumberDataPoint,\n  IResourceMetrics,\n  IScopeMetrics\n} from './types';\n\nexport function toResourceMetrics(resourceMetrics: ResourceMetrics): IResourceMetrics {\n  return {\n    resource: {\n      attributes: toAttributes(resourceMetrics.resource.attributes),\n      droppedAttributesCount: 0\n    },\n    schemaUrl: undefined, // TODO: Schema Url does not exist yet in the SDK.\n    scopeMetrics: toScopeMetrics(resourceMetrics.scopeMetrics)\n  };\n}\n\nexport function toScopeMetrics(scopeMetrics: ScopeMetrics[]): IScopeMetrics[] {\n  return Array.from(scopeMetrics.map(metrics => {\n    const scopeMetrics: IScopeMetrics = {\n      scope: {\n        name: metrics.scope.name,\n        version: metrics.scope.version,\n      },\n      metrics: metrics.metrics.map(metricData => toMetric(metricData)),\n      schemaUrl: metrics.scope.schemaUrl\n    };\n    return scopeMetrics;\n  }));\n}\n\nexport function toMetric(metricData: MetricData): IMetric {\n  const out: IMetric = {\n    name: metricData.descriptor.name,\n    description: metricData.descriptor.description,\n    unit: metricData.descriptor.unit,\n  };\n\n  const aggregationTemporality = toAggregationTemporality(metricData.aggregationTemporality);\n\n  if (metricData.dataPointType === DataPointType.SINGULAR) {\n    const dataPoints = toSingularDataPoints(metricData);\n    const isMonotonic = metricData.descriptor.type === InstrumentType.COUNTER ||\n      metricData.descriptor.type === InstrumentType.OBSERVABLE_COUNTER;\n    if (isSum(metricData)) {\n      out.sum = {\n        aggregationTemporality,\n        isMonotonic,\n        dataPoints\n      };\n\n    } else {\n      // Instrument is a gauge.\n      out.gauge = {\n        dataPoints\n      };\n    }\n  } else if (isHistogram(metricData)) {\n    out.histogram = {\n      aggregationTemporality,\n      dataPoints: toHistogramDataPoints(metricData)\n    };\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoint(dataPoint: DataPoint<number> | DataPoint<Histogram>, valueType: ValueType) {\n  const out: INumberDataPoint = {\n    attributes: toAttributes(dataPoint.attributes),\n    startTimeUnixNano: hrTimeToNanoseconds(\n      dataPoint.startTime\n    ),\n    timeUnixNano: hrTimeToNanoseconds(\n      dataPoint.endTime\n    ),\n  };\n\n  if (valueType === ValueType.INT) {\n    out.asInt = dataPoint.value as number;\n  } else if (valueType === ValueType.DOUBLE) {\n    out.asDouble = dataPoint.value as number;\n  }\n\n  return out;\n}\n\nfunction toSingularDataPoints(\n  metricData: MetricData\n): INumberDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    return toSingularDataPoint(dataPoint, metricData.descriptor.valueType);\n  });\n}\n\nfunction toHistogramDataPoints(\n  metricData: MetricData\n): IHistogramDataPoint[] {\n  return metricData.dataPoints.map(dataPoint => {\n    const histogram = dataPoint.value as Histogram;\n    return {\n      attributes: toAttributes(dataPoint.attributes),\n      bucketCounts: histogram.buckets.counts,\n      explicitBounds: histogram.buckets.boundaries,\n      count: histogram.count,\n      sum: histogram.sum,\n      min: histogram.hasMinMax ? histogram.min : undefined,\n      max: histogram.hasMinMax ? histogram.max : undefined,\n      startTimeUnixNano: hrTimeToNanoseconds(dataPoint.startTime),\n      timeUnixNano: hrTimeToNanoseconds(\n        dataPoint.endTime\n      ),\n    };\n  });\n}\n\nfunction isSum(metric: MetricData) {\n  return (metric.descriptor.type === InstrumentType.COUNTER ||\n    metric.descriptor.type === InstrumentType.UP_DOWN_COUNTER ||\n    metric.descriptor.type === InstrumentType.OBSERVABLE_COUNTER ||\n    metric.descriptor.type === InstrumentType.OBSERVABLE_UP_DOWN_COUNTER);\n}\n\nfunction isHistogram(metric: MetricData) {\n  return metric.dataPointType === DataPointType.HISTOGRAM;\n}\n\nfunction toAggregationTemporality(\n  temporality: AggregationTemporality,\n): EAggregationTemporality {\n  if (temporality === AggregationTemporality.DELTA) {\n    return EAggregationTemporality.AGGREGATION_TEMPORALITY_DELTA;\n  }\n\n  if (temporality === AggregationTemporality.CUMULATIVE) {\n    return EAggregationTemporality.AGGREGATION_TEMPORALITY_CUMULATIVE;\n  }\n\n  return EAggregationTemporality.AGGREGATION_TEMPORALITY_UNSPECIFIED;\n}\n"]}